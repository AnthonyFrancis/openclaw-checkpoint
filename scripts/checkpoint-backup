#!/bin/bash
# checkpoint-backup - Save OpenClaw state to remote repository

set -e

WORKSPACE_DIR="${WORKSPACE_DIR:-$HOME/.openclaw/workspace}"
REMOTE_URL="${CHECKPOINT_REMOTE:-origin}"
BRANCH="${CHECKPOINT_BRANCH:-main}"
LOCK_DIR="$WORKSPACE_DIR/.git/checkpoint.lock"

cd "$WORKSPACE_DIR" || {
    echo "‚ùå Workspace not found at $WORKSPACE_DIR"
    exit 1
}

# Check if git repo exists
if [ ! -d ".git" ]; then
    echo "‚ùå Not a git repository. Run 'checkpoint-init' first."
    exit 1
fi

# ===========================================================================
# CRON JOB BACKUP
# Export OpenClaw cron jobs to JSON for restoration on new machines
# ===========================================================================
backup_cron_jobs() {
    local BACKUP_FILE="$WORKSPACE_DIR/memory/cron-jobs-backup.json"

    # Ensure memory directory exists
    mkdir -p "$WORKSPACE_DIR/memory"

    # Check if openclaw CLI is available
    if ! command -v openclaw >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  OpenClaw CLI not available, skipping cron job backup"
        return 0
    fi

    # Try to get cron jobs
    echo "üíæ Backing up cron jobs..."

    # Use a temporary file to capture output
    TEMP_BACKUP=$(mktemp)

    if openclaw cron list --json 2>/dev/null > "$TEMP_BACKUP"; then
        # Check if we got valid JSON with jobs
        if python3 -c "import json,sys; d=json.load(open('$TEMP_BACKUP')); sys.exit(0 if 'jobs' in d else 1)" 2>/dev/null; then
            # Clean up the backup (remove runtime state, keep config)
            python3 << PYTHON_EOF
import json
import sys
from datetime import datetime

try:
    with open('$TEMP_BACKUP', 'r') as f:
        data = json.load(f)

    jobs = data.get('jobs', [])
    clean_jobs = []

    for job in jobs:
        clean_job = {
            'name': job.get('name'),
            'enabled': job.get('enabled', True),
            'schedule': job.get('schedule'),
            'sessionTarget': job.get('sessionTarget'),
            'wakeMode': job.get('wakeMode'),
            'payload': job.get('payload'),
            'agentId': job.get('agentId', 'main'),
        }
        if job.get('delivery'):
            clean_job['delivery'] = job['delivery']
        if job.get('payload', {}).get('model'):
            clean_job['model'] = job['payload']['model']
        clean_jobs.append(clean_job)

    backup_data = {
        'exported_at': datetime.now().isoformat(),
        'total_jobs': len(clean_jobs),
        'jobs': clean_jobs
    }

    with open('$BACKUP_FILE', 'w') as f:
        json.dump(backup_data, f, indent=2)

    print(f"   ‚úÖ Backed up {len(clean_jobs)} cron jobs")
except Exception as e:
    print(f"   ‚ö†Ô∏è  Cron backup failed: {e}")
    sys.exit(1)
PYTHON_EOF
        else
            echo "   ‚ö†Ô∏è  No cron jobs found or invalid response"
        fi
    else
        echo "   ‚ö†Ô∏è  Could not fetch cron jobs (gateway may not be running)"
    fi

    rm -f "$TEMP_BACKUP"
}

# Backup cron jobs before committing
backup_cron_jobs

# Prevent concurrent runs using mkdir (atomic on all platforms)
cleanup_lock() {
    rmdir "$LOCK_DIR" 2>/dev/null || true
}
trap cleanup_lock EXIT

if ! mkdir "$LOCK_DIR" 2>/dev/null; then
    # Check if lock is stale (older than 5 minutes)
    if [[ "$OSTYPE" == darwin* ]]; then
        LOCK_AGE=$(( $(date +%s) - $(stat -f %m "$LOCK_DIR" 2>/dev/null || echo 0) ))
    else
        LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_DIR" 2>/dev/null || echo 0) ))
    fi
    if [ "$LOCK_AGE" -gt 300 ]; then
        echo "üîì Removing stale lock (${LOCK_AGE}s old)"
        rmdir "$LOCK_DIR" 2>/dev/null || true
        mkdir "$LOCK_DIR" 2>/dev/null || { echo "‚è≥ Another checkpoint is running, skipping"; exit 0; }
    else
        echo "‚è≥ Another checkpoint is already running, skipping"
        exit 0
    fi
fi

# Check if there are changes (staged, unstaged, or untracked)
if git diff --quiet HEAD 2>/dev/null && git diff --cached --quiet 2>/dev/null && [ -z "$(git status --porcelain 2>/dev/null)" ]; then
    echo "‚è≠Ô∏è  No changes to checkpoint"
    exit 0
fi

# Add all changes
echo "üíæ Saving checkpoint..."
git add -A

# Commit with timestamp
git commit -m "checkpoint: $(date '+%Y-%m-%d %H:%M')" --quiet

# Push to remote
echo "‚òÅÔ∏è  Pushing to $REMOTE_URL/$BRANCH..."
if git push "$REMOTE_URL" "$BRANCH" --quiet 2>/dev/null; then
    echo "‚úÖ Checkpoint saved successfully"
    echo "   Time: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "   Commit: $(git rev-parse --short HEAD)"
else
    # Normal push failed - check if local diverged (e.g., after restoring older checkpoint)
    git fetch "$REMOTE_URL" "$BRANCH" --quiet 2>/dev/null || true
    LOCAL_AHEAD=$(git rev-list "$REMOTE_URL/$BRANCH"..HEAD --count 2>/dev/null || echo "0")
    REMOTE_AHEAD=$(git rev-list HEAD.."$REMOTE_URL/$BRANCH" --count 2>/dev/null || echo "0")

    if [ "$REMOTE_AHEAD" -gt 0 ] && [ "$LOCAL_AHEAD" -gt 0 ]; then
        # Diverged history - likely restored an older checkpoint then made changes
        echo ""
        echo "‚ö†Ô∏è  Local history has diverged from remote."
        echo "   This usually happens after restoring an older checkpoint."
        echo ""
        read -p "   Force push to overwrite remote? [y/N]: " FORCE_PUSH
        if [[ "$FORCE_PUSH" =~ ^[Yy]$ ]]; then
            if git push "$REMOTE_URL" "$BRANCH" --force --quiet; then
                echo "‚úÖ Checkpoint saved successfully (force pushed)"
                echo "   Time: $(date '+%Y-%m-%d %H:%M:%S')"
                echo "   Commit: $(git rev-parse --short HEAD)"
            else
                echo "‚ùå Force push failed"
                exit 1
            fi
        else
            echo "   Push cancelled. Run 'checkpoint-restore' to sync with remote first."
            exit 1
        fi
    else
        echo "‚ùå Failed to push checkpoint"
        echo "   You may need to pull first: checkpoint-restore"
        exit 1
    fi
fi
