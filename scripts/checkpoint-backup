#!/bin/bash
# checkpoint-backup - Save OpenClaw state to remote repository

set -e

WORKSPACE_DIR="${WORKSPACE_DIR:-$HOME/.openclaw/workspace}"
REMOTE_URL="${CHECKPOINT_REMOTE:-origin}"
BRANCH="${CHECKPOINT_BRANCH:-main}"
LOCK_DIR="$WORKSPACE_DIR/.git/checkpoint.lock"
AGENTS_DIR="${HOME}/.openclaw/agents"
AGENTS_BACKUP_DIR="${WORKSPACE_DIR}/agents"

# ===========================================================================
# FLAG PARSING
# ===========================================================================
WORKSPACE_ONLY=false
AGENTS_ONLY=false
SINGLE_AGENT=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --workspace-only) WORKSPACE_ONLY=true; shift ;;
        --agents-only) AGENTS_ONLY=true; shift ;;
        --agent)
            if [ -n "${2:-}" ]; then
                SINGLE_AGENT="$2"; shift 2
            else
                echo "‚ùå --agent requires a name argument"
                exit 1
            fi
            ;;
        *) shift ;;
    esac
done

if [ "$WORKSPACE_ONLY" = true ] && [ "$AGENTS_ONLY" = true ]; then
    echo "‚ùå Cannot use --workspace-only and --agents-only together"
    exit 1
fi

cd "$WORKSPACE_DIR" || {
    echo "‚ùå Workspace not found at $WORKSPACE_DIR"
    exit 1
}

# Check if git repo exists
if [ ! -d ".git" ]; then
    echo "‚ùå Not a git repository. Run 'checkpoint-init' first."
    exit 1
fi

# ===========================================================================
# CRON JOB BACKUP
# Export OpenClaw cron jobs to JSON for restoration on new machines
# ===========================================================================
backup_cron_jobs() {
    local BACKUP_FILE="$WORKSPACE_DIR/memory/cron-jobs-backup.json"

    # Ensure memory directory exists
    mkdir -p "$WORKSPACE_DIR/memory"

    # Check if openclaw CLI is available
    if ! command -v openclaw >/dev/null 2>&1; then
        echo "‚ö†Ô∏è  OpenClaw CLI not available, skipping cron job backup"
        return 0
    fi

    # Try to get cron jobs
    echo "üíæ Backing up cron jobs..."

    # Use a temporary file to capture output
    TEMP_BACKUP=$(mktemp)

    if openclaw cron list --json 2>/dev/null > "$TEMP_BACKUP"; then
        # Check if we got valid JSON with jobs
        if python3 -c "import json,sys; d=json.load(open('$TEMP_BACKUP')); sys.exit(0 if 'jobs' in d else 1)" 2>/dev/null; then
            # Clean up the backup (remove runtime state, keep config)
            python3 << PYTHON_EOF
import json
import sys
from datetime import datetime

try:
    with open('$TEMP_BACKUP', 'r') as f:
        data = json.load(f)

    jobs = data.get('jobs', [])
    clean_jobs = []

    for job in jobs:
        clean_job = {
            'name': job.get('name'),
            'enabled': job.get('enabled', True),
            'schedule': job.get('schedule'),
            'sessionTarget': job.get('sessionTarget'),
            'wakeMode': job.get('wakeMode'),
            'payload': job.get('payload'),
            'agentId': job.get('agentId', 'main'),
        }
        if job.get('delivery'):
            clean_job['delivery'] = job['delivery']
        if job.get('payload', {}).get('model'):
            clean_job['model'] = job['payload']['model']
        clean_jobs.append(clean_job)

    backup_data = {
        'exported_at': datetime.now().isoformat(),
        'total_jobs': len(clean_jobs),
        'jobs': clean_jobs
    }

    with open('$BACKUP_FILE', 'w') as f:
        json.dump(backup_data, f, indent=2)

    print(f"   ‚úÖ Backed up {len(clean_jobs)} cron jobs")
except Exception as e:
    print(f"   ‚ö†Ô∏è  Cron backup failed: {e}")
    sys.exit(1)
PYTHON_EOF
        else
            echo "   ‚ö†Ô∏è  No cron jobs found or invalid response"
        fi
    else
        echo "   ‚ö†Ô∏è  Could not fetch cron jobs (gateway may not be running)"
    fi

    rm -f "$TEMP_BACKUP"
}

# ===========================================================================
# AGENT BACKUP
# Copy agent folders from ~/.openclaw/agents/ into workspace agents/ dir
# ===========================================================================
backup_agents() {
    if [ ! -d "$AGENTS_DIR" ]; then
        echo "   ‚ÑπÔ∏è  No agents directory found (~/.openclaw/agents/) ‚Äî skipping agent backup"
        return 0
    fi

    # Build list of agents to back up
    local agents=()
    if [ -n "$SINGLE_AGENT" ]; then
        if [ -d "$AGENTS_DIR/$SINGLE_AGENT" ]; then
            agents=("$SINGLE_AGENT")
        else
            echo "   ‚ùå Agent '$SINGLE_AGENT' not found in $AGENTS_DIR"
            return 1
        fi
    else
        for d in "$AGENTS_DIR"/*/; do
            [ -d "$d" ] && agents+=("$(basename "$d")")
        done
    fi

    if [ ${#agents[@]} -eq 0 ]; then
        echo "   ‚ÑπÔ∏è  No agents found in ~/.openclaw/agents/ ‚Äî skipping agent backup"
        return 0
    fi

    echo "ü§ñ Backing up ${#agents[@]} agent(s)..."
    mkdir -p "$AGENTS_BACKUP_DIR"

    for agent in "${agents[@]}"; do
        local src="$AGENTS_DIR/$agent"
        local dest="$AGENTS_BACKUP_DIR/$agent"

        echo "   ‚Ä¢ $agent..."

        if command -v rsync >/dev/null 2>&1; then
            rsync -a --exclude='.git' "$src/" "$dest/"
        else
            # Fallback: cp then strip .git dirs
            mkdir -p "$dest"
            cp -r "$src/." "$dest/"
            find "$dest" -name ".git" -type d -exec rm -rf {} + 2>/dev/null || true
        fi

        echo "     ‚úÖ $agent backed up"
    done

    echo "   ‚úÖ Agent backup complete"
}

# ===========================================================================
# PATH NORMALIZATION
# Replace literal $HOME paths with {{HOME}} for cross-machine portability
# ===========================================================================
normalize_paths() {
    local FILE_PATTERN='-name "*.md" -o -name "*.json" -o -name "*.sh" -o -name "*.txt" -o -name "*.yaml" -o -name "*.yml" -o -name "*.toml" -o -name "*.cfg" -o -name "*.conf"'
    local ESCAPED_HOME
    ESCAPED_HOME=$(printf '%s\n' "$HOME" | sed 's/[\/&]/\\&/g')

    # Write metadata so restore knows the source machine
    cat > "$WORKSPACE_DIR/.checkpoint-meta.json" << METAEOF
{
  "source_home": "$HOME",
  "source_user": "$(whoami)",
  "hostname": "$(hostname -s 2>/dev/null || hostname)"
}
METAEOF

    # Count files containing the literal home path
    local match_count
    match_count=$(find "$WORKSPACE_DIR" -path "$WORKSPACE_DIR/.git" -prune -o \
        -type f \( -name "*.md" -o -name "*.json" -o -name "*.sh" -o -name "*.txt" \
        -o -name "*.yaml" -o -name "*.yml" -o -name "*.toml" -o -name "*.cfg" -o -name "*.conf" \) \
        -print0 2>/dev/null | xargs -0 grep -l "$HOME" 2>/dev/null | wc -l | tr -d ' ')

    if [ "$match_count" -eq 0 ]; then
        return 0
    fi

    echo "üîÑ Normalizing paths for portability ($match_count file(s))..."

    find "$WORKSPACE_DIR" -path "$WORKSPACE_DIR/.git" -prune -o \
        -type f \( -name "*.md" -o -name "*.json" -o -name "*.sh" -o -name "*.txt" \
        -o -name "*.yaml" -o -name "*.yml" -o -name "*.toml" -o -name "*.cfg" -o -name "*.conf" \) \
        -print0 2>/dev/null | xargs -0 grep -l "$HOME" 2>/dev/null | while IFS= read -r file; do
        if [[ "$OSTYPE" == darwin* ]]; then
            sed -i '' "s|${ESCAPED_HOME}|{{HOME}}|g" "$file"
        else
            sed -i "s|${ESCAPED_HOME}|{{HOME}}|g" "$file"
        fi
    done

    echo "   ‚úÖ Replaced $HOME ‚Üí {{HOME}} in $match_count file(s)"
}

# Backup cron jobs before committing (skip if --agents-only)
if [ "$AGENTS_ONLY" = false ]; then
    backup_cron_jobs
fi

# Backup agents (skip if --workspace-only)
if [ "$WORKSPACE_ONLY" = false ]; then
    backup_agents
fi

# Normalize paths for cross-machine portability
normalize_paths

# Prevent concurrent runs using mkdir (atomic on all platforms)
cleanup_lock() {
    rmdir "$LOCK_DIR" 2>/dev/null || true
}
trap cleanup_lock EXIT

if ! mkdir "$LOCK_DIR" 2>/dev/null; then
    # Check if lock is stale (older than 5 minutes)
    if [[ "$OSTYPE" == darwin* ]]; then
        LOCK_AGE=$(( $(date +%s) - $(stat -f %m "$LOCK_DIR" 2>/dev/null || echo 0) ))
    else
        LOCK_AGE=$(( $(date +%s) - $(stat -c %Y "$LOCK_DIR" 2>/dev/null || echo 0) ))
    fi
    if [ "$LOCK_AGE" -gt 300 ]; then
        echo "üîì Removing stale lock (${LOCK_AGE}s old)"
        rmdir "$LOCK_DIR" 2>/dev/null || true
        mkdir "$LOCK_DIR" 2>/dev/null || { echo "‚è≥ Another checkpoint is running, skipping"; exit 0; }
    else
        echo "‚è≥ Another checkpoint is already running, skipping"
        exit 0
    fi
fi

# Check if there are changes (staged, unstaged, or untracked)
if git diff --quiet HEAD 2>/dev/null && git diff --cached --quiet 2>/dev/null && [ -z "$(git status --porcelain 2>/dev/null)" ]; then
    echo "‚è≠Ô∏è  No changes to checkpoint"
    exit 0
fi

# Add all changes
echo "üíæ Saving checkpoint..."
git add -A

# Commit with timestamp
git commit -m "checkpoint: $(date '+%Y-%m-%d %H:%M')" --quiet

# Push to remote
echo "‚òÅÔ∏è  Pushing to $REMOTE_URL/$BRANCH..."
if git push "$REMOTE_URL" "$BRANCH" --quiet 2>/dev/null; then
    echo "‚úÖ Checkpoint saved successfully"
    echo "   Time: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "   Commit: $(git rev-parse --short HEAD)"
else
    # Normal push failed - check if local diverged (e.g., after restoring older checkpoint)
    git fetch "$REMOTE_URL" "$BRANCH" --quiet 2>/dev/null || true
    LOCAL_AHEAD=$(git rev-list "$REMOTE_URL/$BRANCH"..HEAD --count 2>/dev/null || echo "0")
    REMOTE_AHEAD=$(git rev-list HEAD.."$REMOTE_URL/$BRANCH" --count 2>/dev/null || echo "0")

    if [ "$REMOTE_AHEAD" -gt 0 ] && [ "$LOCAL_AHEAD" -gt 0 ]; then
        # Diverged history - likely restored an older checkpoint then made changes
        echo ""
        echo "‚ö†Ô∏è  Local history has diverged from remote."
        echo "   This usually happens after restoring an older checkpoint."
        echo ""
        read -p "   Force push to overwrite remote? [y/N]: " FORCE_PUSH
        if [[ "$FORCE_PUSH" =~ ^[Yy]$ ]]; then
            if git push "$REMOTE_URL" "$BRANCH" --force --quiet; then
                echo "‚úÖ Checkpoint saved successfully (force pushed)"
                echo "   Time: $(date '+%Y-%m-%d %H:%M:%S')"
                echo "   Commit: $(git rev-parse --short HEAD)"
            else
                echo "‚ùå Force push failed"
                exit 1
            fi
        else
            echo "   Push cancelled. Run 'checkpoint-restore' to sync with remote first."
            exit 1
        fi
    else
        echo "‚ùå Failed to push checkpoint"
        echo "   You may need to pull first: checkpoint-restore"
        exit 1
    fi
fi
