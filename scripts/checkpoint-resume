#!/bin/bash
# checkpoint-resume - Restore OpenClaw state from remote repository

set -e

WORKSPACE_DIR="${WORKSPACE_DIR:-$HOME/.openclaw/workspace}"
REMOTE_URL="${CHECKPOINT_REMOTE:-origin}"
BRANCH="${CHECKPOINT_BRANCH:-main}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ===========================================================================
# CRON JOB RESTORE
# Restore OpenClaw cron jobs from backup file after workspace restore
# Reads memory/cron-jobs-backup.json and calls `openclaw cron add` per job
# ===========================================================================
restore_cron_jobs() {
    local BACKUP_FILE="$WORKSPACE_DIR/memory/cron-jobs-backup.json"

    if [ ! -f "$BACKUP_FILE" ]; then
        return 0
    fi

    # Check if openclaw CLI is available
    if ! command -v openclaw >/dev/null 2>&1; then
        echo ""
        echo "   ‚ÑπÔ∏è  Cron job backup found but OpenClaw CLI not available."
        echo "      Start the gateway first, then run: checkpoint-resume"
        return 0
    fi

    # Count jobs in backup
    local JOB_COUNT
    JOB_COUNT=$(python3 -c "import json; print(len(json.load(open('$BACKUP_FILE')).get('jobs',[])))" 2>/dev/null || echo "0")

    if [ "$JOB_COUNT" -eq 0 ]; then
        return 0
    fi

    echo ""
    echo "üîÑ Cron Job Restore"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "   Found $JOB_COUNT cron jobs in backup"
    echo ""

    read -p "   Restore $JOB_COUNT cron jobs to OpenClaw? [Y/n]: " RESTORE_CRONS
    RESTORE_CRONS=${RESTORE_CRONS:-Y}

    if [[ ! "$RESTORE_CRONS" =~ ^[Yy]$ ]]; then
        echo "   Skipped. Restore later with: checkpoint-resume"
        return 0
    fi

    echo ""
    echo "   Restoring cron jobs..."

    # Write the Python restore script to a temp file to avoid heredoc quoting issues
    local TEMP_SCRIPT
    TEMP_SCRIPT=$(mktemp /tmp/restore_cron_XXXXXX.py)

    cat > "$TEMP_SCRIPT" << 'PYEOF'
import json, subprocess, sys

backup_path = sys.argv[1]

# Detect which delivery flags the CLI supports (varies by version)
try:
    help_out = subprocess.run(
        ['openclaw', 'cron', 'add', '--help'],
        capture_output=True, text=True, timeout=15
    ).stdout + subprocess.run(
        ['openclaw', 'cron', 'add', '--help'],
        capture_output=True, text=True, timeout=15
    ).stderr
except Exception:
    help_out = ''

has_announce = '--announce' in help_out
has_no_deliver = '--no-deliver' in help_out
has_deliver = '--deliver' in help_out and not has_announce  # old-style flag

with open(backup_path, 'r') as f:
    data = json.load(f)

jobs = data.get('jobs', [])
restored = skipped = failed = 0

for job in jobs:
    name = job.get('name', 'Unnamed')
    schedule = job.get('schedule', {})
    payload = job.get('payload', {})

    print(f"   ‚Ä¢ {name}...", end=" ", flush=True)

    cmd = ['openclaw', 'cron', 'add']

    # Name
    if name:
        cmd += ['--name', name]

    # Schedule
    if schedule.get('kind') == 'cron' and schedule.get('expr'):
        cmd += ['--cron', schedule['expr']]
        if schedule.get('tz'):
            cmd += ['--tz', schedule['tz']]
    elif schedule.get('kind') == 'every' and schedule.get('interval'):
        cmd += ['--every', schedule['interval']]
    else:
        print("skipped (no schedule)")
        skipped += 1
        continue

    # Session & wake
    cmd += ['--session', job.get('sessionTarget', 'isolated')]
    cmd += ['--wake', job.get('wakeMode', 'now')]
    cmd += ['--agent', job.get('agentId', 'main')]

    # Model
    model = job.get('model') or payload.get('model')
    if model:
        cmd += ['--model', model]

    # Payload
    if payload.get('message'):
        cmd += ['--message', payload['message']]
    if payload.get('systemEvent'):
        cmd += ['--system-event', payload['systemEvent']]
    if payload.get('timeoutSeconds'):
        cmd += ['--timeout-seconds', str(payload['timeoutSeconds'])]
    if payload.get('thinking'):
        cmd += ['--thinking', payload['thinking']]

    # Delivery - handle both old and new CLI versions
    # New CLI (2026.2.6+): --announce, --no-deliver
    # Old CLI: --deliver (no --announce or --no-deliver)
    delivery = job.get('delivery', {})
    mode = delivery.get('mode', '')
    if mode == 'none':
        if has_no_deliver:
            cmd += ['--no-deliver']
        # Old CLI: omitting delivery flags = no delivery (default)
    elif mode == 'announce' or delivery.get('announce'):
        if has_announce:
            cmd += ['--announce']
        elif has_deliver:
            cmd += ['--deliver']
        if delivery.get('channel'):
            cmd += ['--channel', delivery['channel']]
        if delivery.get('to'):
            cmd += ['--to', str(delivery['to'])]

    # Disabled
    if not job.get('enabled', True):
        cmd += ['--disabled']

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        if result.returncode == 0:
            print("restored")
            restored += 1
        else:
            err = (result.stderr.strip() or result.stdout.strip())[:80]
            print(f"failed ({err})")
            failed += 1
    except subprocess.TimeoutExpired:
        print("timed out")
        failed += 1
    except Exception as e:
        print(f"error ({e})")
        failed += 1

print()
parts = [f"   ‚úÖ Restored {restored} cron jobs"]
if skipped:
    parts.append(f"skipped {skipped}")
if failed:
    parts.append(f"{failed} failed")
print(", ".join(parts))
PYEOF

    python3 "$TEMP_SCRIPT" "$BACKUP_FILE"
    local EXIT_CODE=$?
    rm -f "$TEMP_SCRIPT"
    return $EXIT_CODE
}

# ===========================================================================
# RESTORE ONBOARDING FLOW
# Triggered when no remote is configured (first-time restore scenario)
# ===========================================================================
restore_onboarding() {
    clear
    echo "üîÑ OpenClaw Checkpoint Restore"
    echo "==============================="
    echo ""
    echo "Welcome! It looks like this is a fresh OpenClaw installation."
    echo ""
    echo "Do you have an existing checkpoint backup to restore from?"
    echo ""
    echo "   1) Yes - I have a GitHub repo with my OpenClaw backup"
    echo "   2) No  - I'm setting up OpenClaw for the first time"
    echo ""
    read -p "Choose [1-2]: " RESTORE_CHOICE
    
    if [ "$RESTORE_CHOICE" = "2" ]; then
        echo ""
        echo "No problem! Run 'checkpoint-setup' to create your first backup."
        echo ""
        echo "   checkpoint-setup"
        echo ""
        exit 0
    fi
    
    if [ "$RESTORE_CHOICE" != "1" ]; then
        echo "‚ùå Invalid choice. Please run checkpoint-resume again."
        exit 1
    fi
    
    # Step 1: GitHub Authentication
    echo ""
    echo "üîê Step 1: GitHub Authentication"
    echo ""
    
    # Check if already authenticated with GitHub
    GITHUB_AUTHENTICATED=false
    
    # Test SSH authentication
    if ssh -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
        echo "   ‚úÖ Already authenticated with GitHub (SSH)"
        GITHUB_AUTHENTICATED=true
        AUTH_METHOD="ssh"
    elif command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1; then
        echo "   ‚úÖ Already authenticated with GitHub CLI"
        GITHUB_AUTHENTICATED=true
        AUTH_METHOD="https"
    fi
    
    if [ "$GITHUB_AUTHENTICATED" = false ]; then
        echo "   You need to authenticate with GitHub to access your backup."
        echo ""
        echo "   Choose authentication method:"
        echo ""
        echo "   1) SSH Key (recommended - no token expiry)"
        echo "   2) GitHub CLI (opens browser automatically)"
        echo "   3) Personal Access Token (manual)"
        echo ""
        read -p "Choose [1-3, default: 1]: " AUTH_CHOICE
        AUTH_CHOICE=${AUTH_CHOICE:-1}
        
        case "$AUTH_CHOICE" in
            1)
                AUTH_METHOD="ssh"
                setup_ssh_auth
                ;;
            2)
                AUTH_METHOD="https"
                setup_gh_cli_auth
                ;;
            3)
                AUTH_METHOD="https"
                setup_pat_auth
                ;;
            *)
                AUTH_METHOD="ssh"
                setup_ssh_auth
                ;;
        esac
    fi
    
    # Step 2: Get repository information
    echo ""
    echo "üì¶ Step 2: Connect to your backup repository"
    echo ""
    echo "   Enter the details of your existing checkpoint repository."
    echo ""
    read -p "   GitHub username: " GITHUB_USER
    read -p "   Repository name [openclaw-state]: " REPO_NAME
    REPO_NAME=${REPO_NAME:-openclaw-state}
    
    # Build the remote URL based on auth method
    if [ "$AUTH_METHOD" = "ssh" ]; then
        CLONE_URL="git@github.com:$GITHUB_USER/$REPO_NAME.git"
    else
        CLONE_URL="https://github.com/$GITHUB_USER/$REPO_NAME.git"
    fi
    
    echo ""
    echo "   Repository: $CLONE_URL"
    echo ""
    
    # Step 3: Verify repository exists and is accessible
    echo "üîç Step 3: Verifying repository access..."
    if ! git ls-remote "$CLONE_URL" HEAD >/dev/null 2>&1; then
        echo ""
        echo "   ‚ùå Cannot access repository: $CLONE_URL"
        echo ""
        echo "   Possible issues:"
        echo "   ‚Ä¢ Repository doesn't exist"
        echo "   ‚Ä¢ Repository is private and you don't have access"
        echo "   ‚Ä¢ Authentication failed"
        echo ""
        echo "   Please verify:"
        echo "   ‚Ä¢ The username and repository name are correct"
        echo "   ‚Ä¢ You have access to the repository"
        echo "   ‚Ä¢ Your authentication is set up correctly"
        echo ""
        echo "   To retry authentication: checkpoint-auth"
        exit 1
    fi
    echo "   ‚úÖ Repository accessible"
    
    # Step 4: Restore the backup
    echo ""
    echo "üì• Step 4: Restoring your OpenClaw state..."
    echo ""
    
    # Check if workspace directory exists and has content
    if [ -d "$WORKSPACE_DIR" ]; then
        # Check if it has any meaningful content (not just empty or skills folder)
        EXISTING_FILES=$(find "$WORKSPACE_DIR" -maxdepth 1 -type f -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
        if [ "$EXISTING_FILES" -gt 0 ]; then
            echo "   ‚ö†Ô∏è  Your workspace already has files:"
            ls -la "$WORKSPACE_DIR"/*.md 2>/dev/null | head -5 | sed 's/^/      /'
            echo ""
            echo "   How would you like to proceed?"
            echo ""
            echo "   1) Merge - Keep local files, add remote backup (may cause conflicts)"
            echo "   2) Replace - Discard local files, use remote backup"
            echo "   3) Cancel - Exit without making changes"
            echo ""
            read -p "   Choose [1-3]: " MERGE_CHOICE
            
            case "$MERGE_CHOICE" in
                1)
                    restore_merge "$CLONE_URL"
                    ;;
                2)
                    restore_replace "$CLONE_URL"
                    ;;
                *)
                    echo ""
                    echo "   Cancelled. No changes made."
                    exit 0
                    ;;
            esac
        else
            # Workspace exists but is mostly empty - safe to replace
            restore_replace "$CLONE_URL"
        fi
    else
        # No workspace exists - fresh clone
        restore_fresh "$CLONE_URL"
    fi
    
    # Step 5: Verify restoration
    echo ""
    echo "‚úÖ Step 5: Restoration complete!"
    echo ""
    cd "$WORKSPACE_DIR"
    echo "   Commit: $(git rev-parse --short HEAD)"
    echo "   Time: $(git log -1 --format=%cd --date=iso)"
    echo ""
    echo "   üìù Restored files:"
    git ls-files | grep -E '\.(md|json)$' | head -10 | sed 's/^/      /'
    FILE_COUNT=$(git ls-files | wc -l | tr -d ' ')
    if [ "$FILE_COUNT" -gt 10 ]; then
        echo "      ... and $((FILE_COUNT - 10)) more files"
    fi
    echo ""
    echo "=============================="
    echo "üéâ Your OpenClaw state has been restored!"
    echo ""

    # Offer to restore cron jobs
    restore_cron_jobs

    echo "   Next steps:"
    echo "   ‚Ä¢ Restore your API keys (they're not backed up for security)"
    echo "   ‚Ä¢ Run 'checkpoint-schedule hourly' to enable automatic backups"
    echo "   ‚Ä¢ Start OpenClaw with 'openclaw gateway start'"
    echo ""
}

# SSH authentication setup
setup_ssh_auth() {
    echo ""
    echo "üîë Setting up SSH authentication..."
    
    # Ensure .ssh directory exists
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    
    # Add GitHub to known_hosts if not already there
    if ! grep -q "github.com" ~/.ssh/known_hosts 2>/dev/null; then
        echo "   Adding GitHub to known hosts..."
        ssh-keyscan -t ed25519 github.com >> ~/.ssh/known_hosts 2>/dev/null
        chmod 600 ~/.ssh/known_hosts
    fi
    
    # Check for existing SSH key
    SSH_KEY="$HOME/.ssh/id_ed25519"
    if [ -f "$SSH_KEY" ]; then
        echo "   ‚úÖ Found existing SSH key: $SSH_KEY"
        
        # Test if already authorized
        if ssh -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
            echo "   ‚úÖ SSH key already authorized on GitHub!"
            return 0
        fi
    else
        echo "   Generating new SSH key..."
        ssh-keygen -t ed25519 -C "openclaw-checkpoint" -f "$SSH_KEY" -N ""
        echo "   ‚úÖ SSH key generated"
    fi
    
    # Show public key and guide user to add it
    echo ""
    echo "   Your public key:"
    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    cat "${SSH_KEY}.pub"
    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo ""
    
    # Copy to clipboard if possible
    if [[ "$OSTYPE" == "darwin"* ]]; then
        cat "${SSH_KEY}.pub" | pbcopy
        echo "   üìã Copied to clipboard!"
    elif command -v xclip >/dev/null 2>&1; then
        cat "${SSH_KEY}.pub" | xclip -selection clipboard
        echo "   üìã Copied to clipboard!"
    fi
    
    echo ""
    echo "   Add this key to your GitHub account:"
    echo ""
    read -p "   Press Enter to open GitHub SSH settings..."
    
    if [[ "$OSTYPE" == "darwin"* ]]; then
        open "https://github.com/settings/ssh/new"
    elif command -v xdg-open >/dev/null 2>&1; then
        xdg-open "https://github.com/settings/ssh/new"
    else
        echo "   Please open: https://github.com/settings/ssh/new"
    fi
    
    echo ""
    echo "   Instructions:"
    echo "   1. Title: 'OpenClaw Checkpoint' (or any name)"
    echo "   2. Key: Paste the public key (already copied)"
    echo "   3. Click 'Add SSH key'"
    echo ""
    read -p "   Press Enter when you've added the key..."
    
    # Verify
    echo ""
    echo "   üîç Testing SSH connection..."
    if ssh -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
        echo "   ‚úÖ SSH authentication successful!"
    else
        echo "   ‚ö†Ô∏è  SSH test didn't confirm success, but we'll proceed."
        echo "      If you encounter issues, run: checkpoint-auth"
    fi
}

# GitHub CLI authentication setup
setup_gh_cli_auth() {
    echo ""
    echo "üîß Setting up GitHub CLI authentication..."
    
    if ! command -v gh >/dev/null 2>&1; then
        echo "   GitHub CLI not installed."
        echo ""
        read -p "   Install GitHub CLI? [Y/n]: " INSTALL_GH
        INSTALL_GH=${INSTALL_GH:-Y}
        
        if [[ "$INSTALL_GH" =~ ^[Yy]$ ]]; then
            if [[ "$OSTYPE" == "darwin"* ]]; then
                echo "   Installing via Homebrew..."
                brew install gh
            elif command -v apt-get >/dev/null 2>&1; then
                echo "   Installing via apt..."
                curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
                sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
                echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
                sudo apt update
                sudo apt install gh -y
            else
                echo "   ‚ùå Please install GitHub CLI manually:"
                echo "   https://github.com/cli/cli#installation"
                exit 1
            fi
        else
            echo "   Falling back to SSH authentication..."
            AUTH_METHOD="ssh"
            setup_ssh_auth
            return
        fi
    fi
    
    echo ""
    echo "   üåê Opening browser for GitHub authentication..."
    gh auth login --git-protocol https --web
    gh auth setup-git
    echo "   ‚úÖ GitHub CLI authentication complete!"
}

# Personal Access Token authentication setup
setup_pat_auth() {
    echo ""
    echo "üîë Setting up Personal Access Token..."
    echo ""
    
    TOKEN_URL="https://github.com/settings/tokens/new?description=OpenClaw%20Checkpoint&scopes=repo"
    
    if [[ "$OSTYPE" == "darwin"* ]]; then
        open "$TOKEN_URL"
    elif command -v xdg-open >/dev/null 2>&1; then
        xdg-open "$TOKEN_URL"
    else
        echo "   Please open: $TOKEN_URL"
    fi
    
    echo "   Instructions:"
    echo "   1. Note: 'OpenClaw Checkpoint'"
    echo "   2. Expiration: 90 days (or no expiration)"
    echo "   3. Scopes: Check 'repo' (full control)"
    echo "   4. Click 'Generate token'"
    echo "   5. COPY the token immediately"
    echo ""
    read -p "   Press Enter when you have your token..."
    echo ""
    read -s -p "   Paste your GitHub token: " GITHUB_TOKEN
    echo ""
    
    # Store credentials
    git config --global credential.helper osxkeychain 2>/dev/null || \
    git config --global credential.helper libsecret 2>/dev/null || \
    git config --global credential.helper store
    
    echo "   ‚úÖ Token configured"
}

# Restore by merging into existing workspace
restore_merge() {
    local CLONE_URL="$1"
    
    echo "   Merging remote backup with local files..."
    
    cd "$WORKSPACE_DIR"
    
    # Initialize git if needed
    if [ ! -d ".git" ]; then
        git init --quiet
    fi
    
    # Add remote
    git remote remove origin 2>/dev/null || true
    git remote add origin "$CLONE_URL"
    
    # Fetch remote
    git fetch origin main --quiet 2>/dev/null || git fetch origin master --quiet
    
    # Determine branch name
    if git rev-parse --verify origin/main >/dev/null 2>&1; then
        REMOTE_BRANCH="main"
    else
        REMOTE_BRANCH="master"
    fi
    
    # Commit local changes if any
    git add -A
    if ! git diff --cached --quiet 2>/dev/null; then
        git commit -m "Local state before restore" --quiet
    fi
    
    # Try to merge
    if ! git pull origin "$REMOTE_BRANCH" --allow-unrelated-histories --no-edit 2>/dev/null; then
        echo ""
        echo "   ‚ö†Ô∏è  Merge conflicts detected. You'll need to resolve them manually:"
        git status | grep "both modified" | sed 's/^/      /'
        echo ""
        echo "   After resolving conflicts, run:"
        echo "      cd ~/.openclaw/workspace"
        echo "      git add -A && git commit -m 'Resolved merge conflicts'"
        exit 1
    fi
    
    echo "   ‚úÖ Merge successful"
}

# Restore by replacing local workspace
restore_replace() {
    local CLONE_URL="$1"
    
    echo "   Replacing local workspace with remote backup..."
    
    # Backup skills folder if it exists (it's not part of the checkpoint)
    SKILLS_BACKUP=""
    if [ -d "$WORKSPACE_DIR/skills" ]; then
        SKILLS_BACKUP=$(mktemp -d)
        cp -r "$WORKSPACE_DIR/skills" "$SKILLS_BACKUP/"
    fi
    
    # Backup tools folder if it exists (contains installed checkpoint scripts)
    TOOLS_BACKUP=""
    if [ -d "$WORKSPACE_DIR/tools" ]; then
        TOOLS_BACKUP=$(mktemp -d)
        cp -r "$WORKSPACE_DIR/tools" "$TOOLS_BACKUP/"
    fi
    
    # Change to a safe directory before removing workspace
    cd "$HOME" || cd /tmp
    
    # Remove existing workspace
    rm -rf "$WORKSPACE_DIR"
    
    # Clone fresh
    git clone "$CLONE_URL" "$WORKSPACE_DIR" --quiet
    
    # Restore skills folder
    if [ -n "$SKILLS_BACKUP" ] && [ -d "$SKILLS_BACKUP/skills" ]; then
        cp -r "$SKILLS_BACKUP/skills" "$WORKSPACE_DIR/"
        rm -rf "$SKILLS_BACKUP"
    fi
    
    # Restore tools folder
    if [ -n "$TOOLS_BACKUP" ] && [ -d "$TOOLS_BACKUP/tools" ]; then
        cp -r "$TOOLS_BACKUP/tools" "$WORKSPACE_DIR/"
        rm -rf "$TOOLS_BACKUP"
    fi
    
    echo "   ‚úÖ Workspace replaced with remote backup"
}

# Restore to fresh/empty workspace
restore_fresh() {
    local CLONE_URL="$1"
    
    echo "   Cloning backup to fresh workspace..."
    
    # Ensure parent directory exists
    mkdir -p "$(dirname "$WORKSPACE_DIR")"
    
    # Clone
    git clone "$CLONE_URL" "$WORKSPACE_DIR" --quiet
    
    echo "   ‚úÖ Backup cloned successfully"
}

# ===========================================================================
# MAIN SCRIPT LOGIC
# ===========================================================================

# Check if workspace directory exists
if [ ! -d "$WORKSPACE_DIR" ]; then
    # No workspace at all - definitely need onboarding
    restore_onboarding
    exit 0
fi

cd "$WORKSPACE_DIR" || {
    echo "‚ùå Cannot access workspace at $WORKSPACE_DIR"
    exit 1
}

# Check if git repo exists
if [ ! -d ".git" ]; then
    # Workspace exists but no git repo - need onboarding
    restore_onboarding
    exit 0
fi

# Check if remote is configured
if ! git remote get-url origin >/dev/null 2>&1; then
    # Git repo exists but no remote - need onboarding
    restore_onboarding
    exit 0
fi

# Normal resume flow - remote is configured
echo "‚òÅÔ∏è  Fetching latest checkpoint..."
if ! git fetch "$REMOTE_URL" "$BRANCH" --quiet 2>&1; then
    FETCH_ERROR=$(git fetch "$REMOTE_URL" "$BRANCH" 2>&1)
    
    # Check if it's an authentication/access issue
    if echo "$FETCH_ERROR" | grep -qE "permission denied|Could not read from remote|does not appear to be a git repository"; then
        echo ""
        echo "‚ùå Cannot access remote repository"
        echo ""
        echo "$FETCH_ERROR" | sed 's/^/   /'
        echo ""
        echo "   This could mean:"
        echo "   ‚Ä¢ The repository no longer exists"
        echo "   ‚Ä¢ Your authentication has expired"
        echo "   ‚Ä¢ You don't have access to the repository"
        echo ""
        echo "   Options:"
        echo "   ‚Ä¢ Run 'checkpoint-auth' to re-authenticate"
        echo "   ‚Ä¢ Run 'checkpoint-reset' then 'checkpoint-resume' to start fresh"
        exit 1
    fi
    
    echo "‚ùå Failed to fetch from remote"
    echo "$FETCH_ERROR" | sed 's/^/   /'
    exit 1
fi

# Check if we're behind
LOCAL=$(git rev-parse @)
REMOTE=$(git rev-parse "$REMOTE_URL/$BRANCH")

if [ "$LOCAL" = "$REMOTE" ]; then
    echo "‚úÖ Already up to date"
    echo "   Commit: $(git rev-parse --short HEAD)"
    echo "   Time: $(git log -1 --format=%cd --date=iso)"
    exit 0
fi

# Check for local changes that would be overwritten
if ! git diff --quiet HEAD; then
    echo "‚ö†Ô∏è  You have uncommitted changes"
    echo "   Options:"
    echo "     1. 'checkpoint' - Save your changes first"
    echo "     2. 'checkpoint-resume --force' - Discard local changes"
    exit 1
fi

# Pull latest
echo "üì• Restoring checkpoint..."
if git pull "$REMOTE_URL" "$BRANCH" --quiet; then
    echo "‚úÖ Checkpoint restored successfully"
    echo "   Commit: $(git rev-parse --short HEAD)"
    echo "   Time: $(git log -1 --format=%cd --date=iso)"
    echo ""
    echo "üìù Recent changes:"
    git log --oneline -3 | sed 's/^/   /'

    # Offer to restore cron jobs if backup exists
    restore_cron_jobs
else
    echo "‚ùå Failed to restore checkpoint"
    exit 1
fi
